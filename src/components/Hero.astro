---
import ArrowRight from './icons/ArrowRight.astro';

export interface Props {
  title?: string;
  subtitle?: string;
  primaryCTA?: string;
  secondaryCTA?: string;
  primaryCTALink?: string;
  secondaryCTALink?: string;
  heroImage?: string;
  primaryTextClass?: string;
  secondaryTextClass?: string;
  subtextClass?: string;
  stats?: Array<{
    value: string;
    label: string;
  }>;
}

const {
  title = "Automatisiere deinen Alltag einfacher, als du denkst.",
  subtitle = "Wir bauen intelligente Automatisierungen, die E Mails, Leads, Dokumente und Routineaufgaben sauber verbinden. DSGVO konform, verständlich erklärt, in wenigen Wochen spürbar.",
  primaryCTA = "Jetzt Termin buchen",
  secondaryCTA = "Interaktives Quiz starten",
  primaryCTALink = "#final-cta",
  secondaryCTALink = "#benefits",
  heroImage = "/images/hero/hero1.webp",
  primaryTextClass = "text-gray-900",
  secondaryTextClass = "text-white",
  subtextClass = "text-white",
} = Astro.props;
---

<section
  id="hero"
  class="relative min-h-screen flex items-center justify-center overflow-hidden pt-16 sm:pt-20 lg:pt-32"
>
  <div class="hero-fluid-gradient" data-hero-fluid aria-hidden="true">
    <div class="hero-grain" aria-hidden="true"></div>
  </div>

  <!-- Full-width background image extending to top
  <div id="hero-parallax-container" class="absolute inset-0 -top-16 sm:-top-20">
    <img
      data-parallax
      src={heroImage}
      alt="KI-Automatisierung Dashboard für deutsche Unternehmen"
      class="w-full h-full object-cover"
      loading="eager"
      fetchpriority="high"
      decoding="async"
      style="height: calc(100% + 4rem);"
    />
  </div>-->

  <div
    class="h-full max-w-6xl mx-auto px-3 sm:px-4 md:px-6 lg:px-12 xl:px-16 relative z-10"
  >
    <div class="grid lg:grid-cols-1 gap-10 items-center">
      <!-- LEFT COLUMN: Existing text content -->
      <div class="text-center w-full max-w-8xl mx-auto">

      <h1
        class="hero-title hero-animate font-headline font-black text-3xl sm:text-4xl md:text-5xl lg:text-7xl text-white mb-10 sm:mb-12 md:mb-14 leading-tight max-w-5xl mx-auto -mt-8 sm:-mt-10 lg:-mt-12"
        style="animation-delay: 0.1s; text-shadow: 0 2px 24px rgba(0, 0, 0, 0.45);"
      >
        {title}
      </h1>

      <p
        class="hero-subtitle hero-animate font-medium text-base sm:text-lg md:text-xl text-white/90 mb-7 max-w-4xl mx-auto leading-normal"
        style="animation-delay: 0.25s"
      >
        {subtitle}
      </p>

      <!-- CTA Button with Benefits -->
      <div class="hero-animate" style="animation-delay: 0.8s">
        <div
          class="flex flex-col lg:flex-row items-center justify-center gap-5 mb-3 sm:mb-4 md:mb-2 px-6 sm:px-4"
        >
          <!-- CTA Button -->
          <a
            href={primaryCTALink}
            class={`group bg-white ${primaryTextClass} px-6 sm:px-8 md:px-12 py-3 sm:py-4 rounded-full hover:bg-gray-100 transition-all duration-200 font-bold text-base sm:text-lg shadow-1xl focus:outline-none focus:ring-4 focus:ring-white/30 w-full sm:w-80 md:w-96 text-center cta-button cta-pulse`}
            aria-label={primaryCTA}
          >
            <span class="flex flex-wrap items-center justify-center gap-2">
              <span>{primaryCTA}</span>
              <ArrowRight class="w-4 h-4 sm:w-5 sm:h-5 flex-shrink-0 transition-transform duration-300 group-hover:translate-x-1" />
            </span>
          </a>

          <a
            href={secondaryCTALink}
            class={`group bg-white/10 ${secondaryTextClass} border border-white/30 px-6 sm:px-8 md:px-12 py-3 sm:py-4 rounded-full hover:bg-white/15 hover:border-white/50 transition-all duration-200 font-bold text-base sm:text-lg backdrop-blur-sm focus:outline-none focus:ring-4 focus:ring-white/20 w-full sm:w-80 md:w-96 text-center cta-button`}
            aria-label={secondaryCTA}
          >
            <span class="flex flex-wrap items-center justify-center gap-2">
              <span>{secondaryCTA}</span>
              <ArrowRight class="w-4 h-4 sm:w-5 sm:h-5 flex-shrink-0 transition-transform duration-300 group-hover:translate-x-1" />
            </span>
          </a>
        </div>

        <!-- Risk Reduction Text -->
        <p
          class={`${subtextClass} text-sm mb-2 max-w-l sm:max-w-l mx-auto text-center`}
          style="font-weight: 800 !important;"
        >
          Wir prüfen gemeinsam, welche Lösung in deinem Unternehmen am schnellsten Wirkung zeigt.
        </p>

        <div
          class="hero-scroll-cue hero-animate"
          style="animation-delay: 1.1s"
          aria-hidden="true"
        >
          <span class="hero-scroll-label">Scroll</span>
          <span class="hero-scroll-arrow"></span>
        </div>
      </div>
      </div>
    </div>
  </div>
</section>

<script type="module">
  import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";

  const hero = document.getElementById("hero");
  const container = hero?.querySelector("[data-hero-fluid]");

  const prefersReducedMotion =
    window.matchMedia("(prefers-reduced-motion: reduce)").matches;

  const hasWebGL = (() => {
    try {
      const canvas = document.createElement("canvas");
      return !!(
        window.WebGLRenderingContext &&
        (canvas.getContext("webgl") || canvas.getContext("experimental-webgl"))
      );
    } catch {
      return false;
    }
  })();

  if (!hero || !container || prefersReducedMotion || !hasWebGL) {
    if (hero) {
      hero.classList.remove("hero-fluid-ready");
    }
  } else {
    class TouchTexture {
      constructor() {
        this.size = 64;
        this.width = this.height = this.size;
        this.maxAge = 64;
        this.radius = 0.25 * this.size;
        this.speed = 1 / this.maxAge;
        this.trail = [];
        this.last = null;
        this.initTexture();
      }

      initTexture() {
        this.canvas = document.createElement("canvas");
        this.canvas.width = this.width;
        this.canvas.height = this.height;
        this.ctx = this.canvas.getContext("2d");
        this.ctx.fillStyle = "black";
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        this.texture = new THREE.Texture(this.canvas);
      }

      update() {
        this.clear();
        const speed = this.speed;
        for (let i = this.trail.length - 1; i >= 0; i--) {
          const point = this.trail[i];
          const f = point.force * speed * (1 - point.age / this.maxAge);
          point.x += point.vx * f;
          point.y += point.vy * f;
          point.age++;
          if (point.age > this.maxAge) {
            this.trail.splice(i, 1);
          } else {
            this.drawPoint(point);
          }
        }
        this.texture.needsUpdate = true;
      }

      clear() {
        this.ctx.fillStyle = "black";
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
      }

      addTouch(point) {
        let force = 0;
        let vx = 0;
        let vy = 0;
        const last = this.last;
        if (last) {
          const dx = point.x - last.x;
          const dy = point.y - last.y;
          if (dx === 0 && dy === 0) return;
          const dd = dx * dx + dy * dy;
          const d = Math.sqrt(dd);
          vx = dx / d;
          vy = dy / d;
          force = Math.min(dd * 20000, 2.0);
        }
        this.last = { x: point.x, y: point.y };
        this.trail.push({ x: point.x, y: point.y, age: 0, force, vx, vy });
      }

      drawPoint(point) {
        const pos = {
          x: point.x * this.width,
          y: (1 - point.y) * this.height,
        };

        let intensity = 1;
        if (point.age < this.maxAge * 0.3) {
          intensity = Math.sin(
            (point.age / (this.maxAge * 0.3)) * (Math.PI / 2),
          );
        } else {
          const t = 1 - (point.age - this.maxAge * 0.3) / (this.maxAge * 0.7);
          intensity = -t * (t - 2);
        }
        intensity *= point.force;

        const radius = this.radius;
        const color = `${((point.vx + 1) / 2) * 255}, ${((point.vy + 1) / 2) * 255}, ${intensity * 255}`;
        const offset = this.size * 5;
        this.ctx.shadowOffsetX = offset;
        this.ctx.shadowOffsetY = offset;
        this.ctx.shadowBlur = radius * 1;
        this.ctx.shadowColor = `rgba(${color},${0.2 * intensity})`;

        this.ctx.beginPath();
        this.ctx.fillStyle = "rgba(255,0,0,1)";
        this.ctx.arc(pos.x - offset, pos.y - offset, radius, 0, Math.PI * 2);
        this.ctx.fill();
      }
    }

    class GradientBackground {
      constructor(sceneManager) {
        this.sceneManager = sceneManager;
        this.mesh = null;
        this.uniforms = {
          uTime: { value: 0 },
          uResolution: {
            value: new THREE.Vector2(
              this.sceneManager.size.width,
              this.sceneManager.size.height,
            ),
          },
          uColor1: { value: new THREE.Vector3(0.945, 0.353, 0.133) },
          uColor2: { value: new THREE.Vector3(0.039, 0.055, 0.153) },
          uColor3: { value: new THREE.Vector3(0.945, 0.353, 0.133) },
          uColor4: { value: new THREE.Vector3(0.039, 0.055, 0.153) },
          uColor5: { value: new THREE.Vector3(0.945, 0.353, 0.133) },
          uColor6: { value: new THREE.Vector3(0.039, 0.055, 0.153) },
          uSpeed: { value: 1.2 },
          uIntensity: { value: 1.6 },
          uTouchTexture: { value: null },
          uGrainIntensity: { value: 0.08 },
          uZoom: { value: 1.0 },
          uDarkNavy: { value: new THREE.Vector3(0.039, 0.055, 0.153) },
          uGradientSize: { value: 1.0 },
          uGradientCount: { value: 6.0 },
          uColor1Weight: { value: 1.0 },
          uColor2Weight: { value: 1.0 },
        };
      }

      init() {
        const viewSize = this.sceneManager.getViewSize();
        const geometry = new THREE.PlaneGeometry(
          viewSize.width,
          viewSize.height,
          1,
          1,
        );

        const material = new THREE.ShaderMaterial({
          uniforms: this.uniforms,
          vertexShader: `
            varying vec2 vUv;
            void main() {
              vec3 pos = position.xyz;
              gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.);
              vUv = uv;
            }
          `,
          fragmentShader: `
            uniform float uTime;
            uniform vec2 uResolution;
            uniform vec3 uColor1;
            uniform vec3 uColor2;
            uniform vec3 uColor3;
            uniform vec3 uColor4;
            uniform vec3 uColor5;
            uniform vec3 uColor6;
            uniform float uSpeed;
            uniform float uIntensity;
            uniform sampler2D uTouchTexture;
            uniform float uGrainIntensity;
            uniform float uZoom;
            uniform vec3 uDarkNavy;
            uniform float uGradientSize;
            uniform float uGradientCount;
            uniform float uColor1Weight;
            uniform float uColor2Weight;

            varying vec2 vUv;

            #define PI 3.14159265359

            float grain(vec2 uv, float time) {
              vec2 grainUv = uv * uResolution * 0.5;
              float grainValue = fract(sin(dot(grainUv + time, vec2(12.9898, 78.233))) * 43758.5453);
              return grainValue * 2.0 - 1.0;
            }

            vec3 getGradientColor(vec2 uv, float time) {
              float gradientRadius = uGradientSize;

              vec2 center1 = vec2(
                0.5 + sin(time * uSpeed * 0.4) * 0.4,
                0.5 + cos(time * uSpeed * 0.5) * 0.4
              );
              vec2 center2 = vec2(
                0.5 + cos(time * uSpeed * 0.6) * 0.5,
                0.5 + sin(time * uSpeed * 0.45) * 0.5
              );
              vec2 center3 = vec2(
                0.5 + sin(time * uSpeed * 0.35) * 0.45,
                0.5 + cos(time * uSpeed * 0.55) * 0.45
              );
              vec2 center4 = vec2(
                0.5 + cos(time * uSpeed * 0.5) * 0.4,
                0.5 + sin(time * uSpeed * 0.4) * 0.4
              );
              vec2 center5 = vec2(
                0.5 + sin(time * uSpeed * 0.7) * 0.35,
                0.5 + cos(time * uSpeed * 0.6) * 0.35
              );
              vec2 center6 = vec2(
                0.5 + cos(time * uSpeed * 0.45) * 0.5,
                0.5 + sin(time * uSpeed * 0.65) * 0.5
              );
              vec2 center7 = vec2(
                0.5 + sin(time * uSpeed * 0.55) * 0.38,
                0.5 + cos(time * uSpeed * 0.48) * 0.42
              );
              vec2 center8 = vec2(
                0.5 + cos(time * uSpeed * 0.65) * 0.36,
                0.5 + sin(time * uSpeed * 0.52) * 0.44
              );
              vec2 center9 = vec2(
                0.5 + sin(time * uSpeed * 0.42) * 0.41,
                0.5 + cos(time * uSpeed * 0.58) * 0.39
              );
              vec2 center10 = vec2(
                0.5 + cos(time * uSpeed * 0.48) * 0.37,
                0.5 + sin(time * uSpeed * 0.62) * 0.43
              );
              vec2 center11 = vec2(
                0.5 + sin(time * uSpeed * 0.68) * 0.33,
                0.5 + cos(time * uSpeed * 0.44) * 0.46
              );
              vec2 center12 = vec2(
                0.5 + cos(time * uSpeed * 0.38) * 0.39,
                0.5 + sin(time * uSpeed * 0.56) * 0.41
              );

              float dist1 = length(uv - center1);
              float dist2 = length(uv - center2);
              float dist3 = length(uv - center3);
              float dist4 = length(uv - center4);
              float dist5 = length(uv - center5);
              float dist6 = length(uv - center6);
              float dist7 = length(uv - center7);
              float dist8 = length(uv - center8);
              float dist9 = length(uv - center9);
              float dist10 = length(uv - center10);
              float dist11 = length(uv - center11);
              float dist12 = length(uv - center12);

              float influence1 = 1.0 - smoothstep(0.0, gradientRadius, dist1);
              float influence2 = 1.0 - smoothstep(0.0, gradientRadius, dist2);
              float influence3 = 1.0 - smoothstep(0.0, gradientRadius, dist3);
              float influence4 = 1.0 - smoothstep(0.0, gradientRadius, dist4);
              float influence5 = 1.0 - smoothstep(0.0, gradientRadius, dist5);
              float influence6 = 1.0 - smoothstep(0.0, gradientRadius, dist6);
              float influence7 = 1.0 - smoothstep(0.0, gradientRadius, dist7);
              float influence8 = 1.0 - smoothstep(0.0, gradientRadius, dist8);
              float influence9 = 1.0 - smoothstep(0.0, gradientRadius, dist9);
              float influence10 = 1.0 - smoothstep(0.0, gradientRadius, dist10);
              float influence11 = 1.0 - smoothstep(0.0, gradientRadius, dist11);
              float influence12 = 1.0 - smoothstep(0.0, gradientRadius, dist12);

              vec2 rotatedUv1 = uv - 0.5;
              float angle1 = time * uSpeed * 0.15;
              rotatedUv1 = vec2(
                rotatedUv1.x * cos(angle1) - rotatedUv1.y * sin(angle1),
                rotatedUv1.x * sin(angle1) + rotatedUv1.y * cos(angle1)
              );
              rotatedUv1 += 0.5;

              vec2 rotatedUv2 = uv - 0.5;
              float angle2 = -time * uSpeed * 0.12;
              rotatedUv2 = vec2(
                rotatedUv2.x * cos(angle2) - rotatedUv2.y * sin(angle2),
                rotatedUv2.x * sin(angle2) + rotatedUv2.y * cos(angle2)
              );
              rotatedUv2 += 0.5;

              float radialGradient1 = length(rotatedUv1 - 0.5);
              float radialGradient2 = length(rotatedUv2 - 0.5);
              float radialInfluence1 = 1.0 - smoothstep(0.0, 0.8, radialGradient1);
              float radialInfluence2 = 1.0 - smoothstep(0.0, 0.8, radialGradient2);

              vec3 color = vec3(0.0);
              color += uColor1 * influence1 * (0.55 + 0.45 * sin(time * uSpeed)) * uColor1Weight;
              color += uColor2 * influence2 * (0.55 + 0.45 * cos(time * uSpeed * 1.2)) * uColor2Weight;
              color += uColor3 * influence3 * (0.55 + 0.45 * sin(time * uSpeed * 0.8)) * uColor1Weight;
              color += uColor4 * influence4 * (0.55 + 0.45 * cos(time * uSpeed * 1.3)) * uColor2Weight;
              color += uColor5 * influence5 * (0.55 + 0.45 * sin(time * uSpeed * 1.1)) * uColor1Weight;
              color += uColor6 * influence6 * (0.55 + 0.45 * cos(time * uSpeed * 0.9)) * uColor2Weight;

              if (uGradientCount > 6.0) {
                color += uColor1 * influence7 * (0.55 + 0.45 * sin(time * uSpeed * 1.4)) * uColor1Weight;
                color += uColor2 * influence8 * (0.55 + 0.45 * cos(time * uSpeed * 1.5)) * uColor2Weight;
                color += uColor3 * influence9 * (0.55 + 0.45 * sin(time * uSpeed * 1.6)) * uColor1Weight;
                color += uColor4 * influence10 * (0.55 + 0.45 * cos(time * uSpeed * 1.7)) * uColor2Weight;
              }
              if (uGradientCount > 10.0) {
                color += uColor5 * influence11 * (0.55 + 0.45 * sin(time * uSpeed * 1.8)) * uColor1Weight;
                color += uColor6 * influence12 * (0.55 + 0.45 * cos(time * uSpeed * 1.9)) * uColor2Weight;
              }

              color += mix(uColor1, uColor3, radialInfluence1) * 0.45 * uColor1Weight;
              color += mix(uColor2, uColor4, radialInfluence2) * 0.4 * uColor2Weight;

              color = clamp(color, vec3(0.0), vec3(1.0)) * uIntensity;

              float luminance = dot(color, vec3(0.299, 0.587, 0.114));
              color = mix(vec3(luminance), color, 1.35);

              color = pow(color, vec3(0.92));

              float brightness1 = length(color);
              float mixFactor1 = max(brightness1 * 1.2, 0.15);
              color = mix(uDarkNavy, color, mixFactor1);

              float maxBrightness = 1.0;
              float brightness = length(color);
              if (brightness > maxBrightness) {
                color = color * (maxBrightness / brightness);
              }

              return color;
            }

            void main() {
              vec2 uv = vUv;

              vec4 touchTex = texture2D(uTouchTexture, uv);
              float vx = -(touchTex.r * 2.0 - 1.0);
              float vy = -(touchTex.g * 2.0 - 1.0);
              float intensity = touchTex.b;
              uv.x += vx * 0.8 * intensity;
              uv.y += vy * 0.8 * intensity;

              vec2 center = vec2(0.5);
              float dist = length(uv - center);
              float ripple = sin(dist * 20.0 - uTime * 3.0) * 0.04 * intensity;
              float wave = sin(dist * 15.0 - uTime * 2.0) * 0.03 * intensity;
              uv += vec2(ripple + wave);

              vec3 color = getGradientColor(uv, uTime);

              float grainValue = grain(uv, uTime);
              color += grainValue * uGrainIntensity;

              float timeShift = uTime * 0.5;
              color.r += sin(timeShift) * 0.02;
              color.g += cos(timeShift * 1.4) * 0.02;
              color.b += sin(timeShift * 1.2) * 0.02;

              float brightness2 = length(color);
              float mixFactor2 = max(brightness2 * 1.2, 0.15);
              color = mix(uDarkNavy, color, mixFactor2);

              color = clamp(color, vec3(0.0), vec3(1.0));

              float maxBrightness = 1.0;
              float brightness = length(color);
              if (brightness > maxBrightness) {
                color = color * (maxBrightness / brightness);
              }

              gl_FragColor = vec4(color, 1.0);
            }
          `,
        });

        this.mesh = new THREE.Mesh(geometry, material);
        this.mesh.position.z = 0;
        this.sceneManager.scene.add(this.mesh);
      }

      update(delta) {
        if (this.uniforms.uTime) {
          this.uniforms.uTime.value += delta;
        }
      }

      onResize(width, height) {
        const viewSize = this.sceneManager.getViewSize();
        if (this.mesh) {
          this.mesh.geometry.dispose();
          this.mesh.geometry = new THREE.PlaneGeometry(
            viewSize.width,
            viewSize.height,
            1,
            1,
          );
        }
        if (this.uniforms.uResolution) {
          this.uniforms.uResolution.value.set(width, height);
        }
      }
    }

    class HeroFluidGradient {
      constructor({ root, target }) {
        this.root = root;
        this.target = target;
        this.size = { width: 0, height: 0 };

        this.renderer = new THREE.WebGLRenderer({
          antialias: true,
          powerPreference: "high-performance",
          alpha: false,
          stencil: false,
          depth: false,
        });

        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        this.renderer.domElement.classList.add("hero-fluid-canvas");
        this.target.appendChild(this.renderer.domElement);

        this.camera = new THREE.PerspectiveCamera(45, 1, 0.1, 10000);
        this.camera.position.z = 50;
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x0a0e27);
        this.clock = new THREE.Clock();

        this.touchTexture = new TouchTexture();
        this.gradientBackground = new GradientBackground(this);
        this.gradientBackground.uniforms.uTouchTexture.value =
          this.touchTexture.texture;

        this.gradientBackground.init();
        this.applyScheme();
        this.onResize();
        this.bindEvents();
        this.tick();
        this.root.classList.add("hero-fluid-ready");
      }

      applyScheme() {
        const uniforms = this.gradientBackground.uniforms;
        uniforms.uColor1.value.set(0.945, 0.353, 0.133);
        uniforms.uColor2.value.set(0.039, 0.055, 0.153);
        uniforms.uColor3.value.set(0.945, 0.353, 0.133);
        uniforms.uColor4.value.set(0.039, 0.055, 0.153);
        uniforms.uColor5.value.set(0.945, 0.353, 0.133);
        uniforms.uColor6.value.set(0.039, 0.055, 0.153);
        uniforms.uDarkNavy.value.set(0.039, 0.055, 0.153);
        uniforms.uGradientSize.value = 0.45;
        uniforms.uGradientCount.value = 12.0;
        uniforms.uSpeed.value = 1.5;
        uniforms.uColor1Weight.value = 0.5;
        uniforms.uColor2Weight.value = 1.8;
      }

      getViewSize() {
        const fovInRadians = (this.camera.fov * Math.PI) / 180;
        const height = Math.abs(
          this.camera.position.z * Math.tan(fovInRadians / 2) * 2,
        );
        return { width: height * this.camera.aspect, height };
      }

      bindEvents() {
        this.onPointerMove = (ev) => {
          const rect = this.target.getBoundingClientRect();
          if (!rect.width || !rect.height) return;
          const x = (ev.clientX - rect.left) / rect.width;
          const y = (ev.clientY - rect.top) / rect.height;
          if (x < 0 || x > 1 || y < 0 || y > 1) return;
          this.touchTexture.addTouch({ x, y: 1 - y });
        };

        this.onResizeBound = () => this.onResize();
        window.addEventListener("pointermove", this.onPointerMove, {
          passive: true,
        });
        window.addEventListener("resize", this.onResizeBound);

        if ("ResizeObserver" in window) {
          this.resizeObserver = new ResizeObserver(() => this.onResize());
          this.resizeObserver.observe(this.target);
        }
      }

      update(delta) {
        this.touchTexture.update();
        this.gradientBackground.update(delta);
      }

      render() {
        const delta = Math.min(this.clock.getDelta(), 0.1);
        this.renderer.render(this.scene, this.camera);
        this.update(delta);
      }

      tick() {
        this.render();
        requestAnimationFrame(() => this.tick());
      }

      onResize() {
        const rect = this.target.getBoundingClientRect();
        if (!rect.width || !rect.height) return;
        this.size.width = rect.width;
        this.size.height = rect.height;
        this.camera.aspect = this.size.width / this.size.height;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(this.size.width, this.size.height);
        this.gradientBackground.onResize(this.size.width, this.size.height);
      }
    }

    new HeroFluidGradient({ root: hero, target: container });
  }
</script>
